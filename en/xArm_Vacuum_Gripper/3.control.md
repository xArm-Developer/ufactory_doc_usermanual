# 3. **Control**

## 3.1**Use xArm Studio to Control xArm Vacuum Gripper**

**1. Set up xArm Vacuum Gripper**

- Enter [Settings]-[Motion]-[TCP]

![](assets/img_5.png)

After installing the vacuum head, set the Tcp load and offset, select the 'xArm Vacuum Gripper' and remember to save it!

**2. Control xArm Vacuum Gripper**

- Control the vacuum gripper in the live control

Control Method:

\1) By clicking the [Open]/[Close] button, you can control the opening and closing of the vacuum gripper\.

![](assets/img_6.png)


- Control the vacuum gripper through Blockly

![](assets/img_7.png)

Find the file 1008_xArm_Vacuum_Gripper in the blockly module

The role of this program: execute this program to control the vacuum gripper to suck the target object at the specified position, and then place the target object at the target position.

Note:

1) When the vacuum gripper is installed on the robotic arm, the TCP Payload of the vacuum gripper should be set in the Blockly program. When the total weight of the vacuum gripper changes after the object is sucked, a new TCP Payload needs to be set.

## 3.2 **Use Python-SDK to Control xArm Vacuum Gripper**

The interface of controling vacuum gripper：

```
arm.set\_vacuum\_gripper(True, wait=False)    #open the vacuum gripper 

arm.set\_vacuum\_gripper(False, wait=False)   #close the vacuum gripper 

```
The download link of the Python-SDK:

[https://github.com/xArm-Developer/xArm-Python-SDK]( )

## 3.3 **Use ROS-SDK to Control xArm Vacuum Gripper**
Please refer to Section 5.7.8 in the ReadMe file attached to the ROS package to control the vacuum gripper.

xArm ROS-SDK link :

https://github.com/xArm-Developer/xarm_ros

## 3.4 **Use Modbus-TCP Communication Protocol to Control   xArm Vacuum Gripper**


his section mainly explains how to control the xArm Vacuum Gripper by using the Modbus-TCP protocol through xArm control box.


### 3.4.1 **Modbus-TCP Communication Format**
**Modbus-TCP:**

Modbus protocol is an application layer message transmission protocol, including three message types: ASCII, RTU, and TCP. The standard Modbus protocol physical layer interface includes RS232, RS422, RS485 and Ethernet interfaces, and adopts master / slave communication.

**Modbus TCP Communication Process:**

1. Establish a TCP connection
2. Prepare Modbus messages
3. Use the send command to send a message
4. Waiting for a response under the same connection 
5. Use the recv command to read the message and complete a data exchange
6. When the communication task ends, close the TCP connection

**Parameter:**

Default TCP Port: 502   

Protocol: 0x00 0x02 

**On the problem of users using communication protocols to organize data in big endian and little endian:**

In this article, data analysis is big-endian analysis.

### **Control of the xArm Vacuum Gripper**

- **Open/Close the vacuum gripper**

|**Open the Vacuum Gripper**|<p>00 01 00 02 00 08 7F 09 0A 15 00 80 80 43</p><p>00 01 00 02 00 08 7F 09 0A 15 00 00 00 44</p>|
| :-: | :- |
|**Close the Vacuum Gripper**|<p>00 01 00 02 00 08 7F 09 0A 15 00 00 80 43</p><p>00 01 00 02 00 08 7F 09 0A 15 00 80 00 44</p>|

**Please refer to the table below for specific parameters.**

<table><tr><th colspan="5"><b>IO control on the End-effector</b></th></tr>
<tr><td colspan="5"><b>Register：127 (0x7F)</b></td></tr>
<tr><td colspan="5"><b>Request</b></td></tr>
<tr><td colspan="1" rowspan="4">Modbus TCP Header</td><td colspan="1">Transaction Identifier</td><td colspan="1">2 Bytes</td><td colspan="1">u16</td><td colspan="1">0x00,0x01</td></tr>
<tr><td colspan="1">Protocol</td><td colspan="1">2 Bytes</td><td colspan="1">u16</td><td colspan="1">0x00,0x02</td></tr>
<tr><td colspan="1">Length</td><td colspan="1">2 Bytes</td><td colspan="1">u16</td><td colspan="1">0x00,0x08</td></tr>
<tr><td colspan="1">Register</td><td colspan="1">1 Byte</td><td colspan="1">u8</td><td colspan="1">0x7F</td></tr>
<tr><td colspan="1" rowspan="3">Parameters</td><td colspan="1">Host ID</td><td colspan="1">1 Byte</td><td colspan="1">u8</td><td colspan="1" valign="top">0x09</td></tr>
<tr><td colspan="1">Address</td><td colspan="1">2 Bytes</td><td colspan="1">u16</td><td colspan="1" valign="top">0x0A,0x15</td></tr>
<tr><td colspan="1"><p>Parameters1(Open 0)</p><p>Data:</p><p>256\.0: Close 0  257.0: Open 0</p><p>512\.0: Close 1  514.0: Open 1</p><p></p></td><td colspan="1">4 Bytes</td><td colspan="1">fp32</td><td colspan="1" valign="top"><p></p><p></p><p>0x00,0x80,0x80,0x43</p><p></p></td></tr>
<tr><td colspan="5"><b>Response</b></td></tr>
<tr><td colspan="1" rowspan="4">Modbus TCP Header</td><td colspan="1">Transaction Identifier</td><td colspan="1">2 Bytes</td><td colspan="1">u16</td><td colspan="1" valign="top">0x00,0x01</td></tr>
<tr><td colspan="1">Protocol</td><td colspan="1">2 Bytes</td><td colspan="1">u16</td><td colspan="1" valign="top">0x00,0x02</td></tr>
<tr><td colspan="1">Length</td><td colspan="1">2 Bytes</td><td colspan="1">u16</td><td colspan="1" valign="top">0x00,0x02</td></tr>
<tr><td colspan="1">Register</td><td colspan="1">1 Byte</td><td colspan="1">u8</td><td colspan="1" valign="top">0x7F</td></tr>
<tr><td colspan="1">Parameters</td><td colspan="1">State</td><td colspan="1">1 Byte</td><td colspan="1">u8</td><td colspan="1" valign="top">0x00</td></tr>
</table>

- **Get the status of the vacuum gripper**

The steps to obtain the vacuum gripper status are shown in the following table:

|**Get Status（Request Commands）**|00 01 00 02 00 04 80 09 0A 14|
| :-: | - |
|<p>**Get Status（Response Commands）**</p><p>**（The vacuum gripper picked up the object）**</p>|00 01 00 02 00 06 80 00 00 00 00 01|
|<p>**Get Status（Response Commands）**</p><p>**（The vacuum gripper does not pick up the object）**</p>|00 01 00 02 00 06 80 00 00 00 00 00|

**Please refer to the table below for specific parameters.**

<table><tr><th colspan="5"><b>Get the input of the end digital quantity</b></th></tr>
<tr><td colspan="5"><b>Register：128 (0x80)</b></td></tr>
<tr><td colspan="5"><b>Request</b></td></tr>
<tr><td colspan="1" rowspan="4">Modbus TCP Header</td><td colspan="1">Transaction Identifier</td><td colspan="1">2 Bytes</td><td colspan="1">u16</td><td colspan="1">0x00,0x01</td></tr>
<tr><td colspan="1">Protocol</td><td colspan="1">2 Bytes</td><td colspan="1">u16</td><td colspan="1">0x00,0x02</td></tr>
<tr><td colspan="1">Length</td><td colspan="1">2 Bytes</td><td colspan="1">u16</td><td colspan="1">0x00,0x04</td></tr>
<tr><td colspan="1">Register</td><td colspan="1">1 Byte</td><td colspan="1">u8</td><td colspan="1">0x80</td></tr>
<tr><td colspan="1" rowspan="2">Parameters</td><td colspan="1">Host ID</td><td colspan="1">1 Byte</td><td colspan="1">u8</td><td colspan="1" valign="top">0x09</td></tr>
<tr><td colspan="1">Address</td><td colspan="1">2 Bytes</td><td colspan="1">u16</td><td colspan="1" valign="top">0x0A, 0x14</td></tr>
<tr><td colspan="5"><b>Response</b></td></tr>
<tr><td colspan="1" rowspan="4">Modbus TCP Header</td><td colspan="1">Transaction Identifier</td><td colspan="1">2 Bytes</td><td colspan="1">u16</td><td colspan="1" valign="top">0x00,0x01</td></tr>
<tr><td colspan="1">Protocol</td><td colspan="1">2 Bytes</td><td colspan="1">u16</td><td colspan="1" valign="top">0x00,0x02</td></tr>
<tr><td colspan="1">Length</td><td colspan="1">2 Bytes</td><td colspan="1">u16</td><td colspan="1" valign="top">0x00,0x06</td></tr>
<tr><td colspan="1">Register</td><td colspan="1">1 Byte</td><td colspan="1">u8</td><td colspan="1" valign="top">0x80</td></tr>
<tr><td colspan="1" rowspan="2">Parameters</td><td colspan="1">State </td><td colspan="1">1 Byte</td><td colspan="1">u8</td><td colspan="1" valign="top">0x00</td></tr>
<tr><td colspan="1"><p>Parameters1（0）</p><p>The end byte indicates the input status. The digit of 0 corresponds to input 0 and the digit of 1 corresponds to input 1.</p></td><td colspan="1"><p></p><p>4 Bytes</p><p></p></td><td colspan="1"><p></p><p>u8*4</p><p></p><p></p></td><td colspan="1" valign="top"><p></p><p>0x00,0x00,0x00,0x00</p><p></p></td></tr>
</table>








